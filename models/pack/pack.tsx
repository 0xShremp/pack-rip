/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./models/card-rip-03/card-rip-v0.5.1.gltf --transform 
Files: ./models/card-rip-03/card-rip-v0.5.1.gltf [14.01KB] > /Users/tillhinrichs/_DEV/PACK_RIP/react/card-rip-v0.5.1-transformed.glb [169.24KB] (-1108%)
*/

import { useAnimations, useGLTF, useTexture } from "@react-three/drei";
import { useFrame, useGraph } from "@react-three/fiber";
import React from "react";
import * as THREE from "three";
import { SkeletonUtils } from "three-stdlib";

export interface PackProps {
  ripPack: boolean;
  playIntro: boolean;
  playOutro: boolean;
  onIntroComplete?: () => void;
  onRipComplete?: () => void;
  onOutroComplete?: () => void;
  rotation: [number, number, number];
  textureUrl?: string;
}

export function Pack({
  ripPack,
  playIntro,
  playOutro,
  onIntroComplete,
  onRipComplete,
  onOutroComplete,
  textureUrl,
  ...props
}: PackProps) {
  const group = React.useRef<THREE.Group>(null);
  const { scene, animations } = useGLTF("/models/pack-transformed.glb");
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone) as unknown as {
    nodes: {
      Bone: THREE.Bone;
      BoneControl: THREE.Bone;
      packbottom: THREE.Mesh;
      packtop: THREE.SkinnedMesh;
    };
    materials: {
      pack: THREE.MeshStandardMaterial;
    };
  };

  // Load custom texture if provided
  const texture = useTexture(
    textureUrl || "/default-pack-texture.png",
    (loadedTexture) => {
      if (Array.isArray(loadedTexture)) return;
      loadedTexture.flipY = false;
      loadedTexture.colorSpace = THREE.SRGBColorSpace;
    }
  );

  // Apply texture to material - create new material to avoid mutating
  const packMaterial = React.useMemo(() => {
    if (texture && materials.pack) {
      const mat = materials.pack.clone();
      mat.map = texture;
      mat.needsUpdate = true;
      return mat;
    }
    return materials.pack;
  }, [texture, materials.pack]);

  const { actions, mixer } = useAnimations(animations, group);
  const [showRip, setShowRip] = React.useState(true);
  const [introProgress, setIntroProgress] = React.useState(0);
  const [outroProgress, setOutroProgress] = React.useState(0);
  const [isIntroPlaying, setIsIntroPlaying] = React.useState(false);
  const [hasPlayedIntro, setHasPlayedIntro] = React.useState(false);
  const [isOutroPlaying, setIsOutroPlaying] = React.useState(false);

  // Intro animation (fly in from bottom with 360° rotation)
  React.useEffect(() => {
    if (playIntro && !isIntroPlaying && !hasPlayedIntro) {
      // console.log("Starting intro animation");
      setIsIntroPlaying(true);
      setIntroProgress(0);
      setHasPlayedIntro(true);
    }
  }, [playIntro, isIntroPlaying, hasPlayedIntro]);

  // Outro animation (fly out to bottom)
  React.useEffect(() => {
    if (playOutro && !isOutroPlaying) {
      setIsOutroPlaying(true);
      setOutroProgress(0);
    }
  }, [playOutro, isOutroPlaying]);

  useFrame((state, delta) => {
    if (!group.current) return;

    // Intro animation
    if (isIntroPlaying && introProgress < 1) {
      const newProgress = Math.min(introProgress + delta * 0.5, 1);
      setIntroProgress(newProgress);

      // Easing function (ease out cubic)
      const eased = 1 - Math.pow(1 - newProgress, 3);

      // Fly in from bottom
      group.current.position.y = -5 + eased * 5;

      // 360° rotation - start from the base rotation (props.rotation[1])
      const baseRotationY = props.rotation[1];
      group.current.rotation.y = baseRotationY - Math.PI * 2 * (1 - eased);

      if (newProgress >= 1) {
        setIsIntroPlaying(false);
        group.current.rotation.y = baseRotationY;
        if (onIntroComplete) onIntroComplete();
      }
    }

    // Outro animation
    if (isOutroPlaying && outroProgress < 1) {
      const newProgress = Math.min(outroProgress + delta * 0.8, 1);
      setOutroProgress(newProgress);

      const eased = Math.pow(newProgress, 3);

      group.current.position.y = -eased * 5;

      if (newProgress >= 1) {
        setIsOutroPlaying(false);
        // console.log("Outro animation completed");
        if (onOutroComplete) onOutroComplete();
      }
    }
  });

  // Rip animation
  React.useEffect(() => {
    if (ripPack) {
      console.log("start rip animation");

      actions.rip?.reset();
      setShowRip(true);
      const animation = actions.rip?.play();

      if (animation) {
        animation.loop = 2200;
        animation.clampWhenFinished = true;

        const onFinished = () => {
          // console.log("rip animation completed");
          setShowRip(false);
          if (onRipComplete) onRipComplete();
          mixer.removeEventListener("finished", onFinished);
        };
        mixer.addEventListener("finished", onFinished);
      }
    }
  }, [ripPack, onRipComplete, actions, mixer]);

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group
          name="Armature"
          position={[0, 0.354, -0.347]}
          rotation={[Math.PI / 2, 0, 0]}
          scale={0.082}
        >
          <primitive object={nodes.Bone} />
          <primitive object={nodes.BoneControl} />
        </group>
        <mesh
          name="packbottom"
          geometry={nodes.packbottom.geometry}
          material={packMaterial}
        />
        <skinnedMesh
          name="packtop"
          geometry={nodes.packtop.geometry}
          material={packMaterial}
          skeleton={nodes.packtop.skeleton}
          position={[0, 0.354, -0.347]}
          rotation={[Math.PI / 2, 0, 0]}
          scale={0.082}
          visible={showRip}
        />
      </group>
    </group>
  );
}

useGLTF.preload("/models/pack-transformed.glb");
